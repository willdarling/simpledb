William Darling
3/15/19
Databases
Aaron Elmore

Describe any design decisions you made, including your deadlock detection
policy, locking granularity, etc.

  The first major design decision came in implementing the LockManager. This had to be done
  from scratch. I chose to model a lock using a ConcurrentHashMap where a page p would be considered
  locked by a given transaction t, if there was a key value pair <PageId of p, TransactionId of t> in
  the hash map. I maintained two hashmaps for shared and exclusive locks. Since exclusive locks can
  only be held by one transaction, this simple mapping worked as is. But for shared locks, a locked
  page PageId would be the key for an ArrayList of TransactionIds, corresponding to all the transactions
  who held a shared lock on that page. If a PageId did not correspond to an entry in either hashmap, the
  page is not locked.

  The lock manager also maintains another ConcurrentHashMap, accessCount, that is used for simple timer
  based deadlock detection. It keeps track of how many times a given transaction has tried to obtain a lock.
  If the transaction reaches a certain threshhold, the LockManager assumes deadlock and throws a
  transactionAbortedException.

  Finally, the lock manager keeps one final ConcurrentHashMap that keeps track of which locks each transaction
  holds. This makes it easier to release all the locks associated with a transaction during transactionComplete().

  I had plans to implement tuple granularity locking and dependency graph based deadlock detection, but due
  to time constraints, and the fact I was working alone, I was unable to accomplish this. My design for tuple
  granularity locking would have been to create a TupleId class similar to PageId, which would assign a unique
  hash to each tuple. Then change the ConcurrentHashMaps to use TupleId instead of PageId for its keys. We then
  move calls to addLock() and releaseLock() out of getPage() and releasePage() into the iterators and operators.
  For dependency graph deadlock detection, I would have used another ConcurrentHashmap with key-value pairs
  <TransactionId, ArrayList<TransactionId>> in which each key represents one node of the map, and the associated
  array holds the nodes to which the key node has a directed edge. 

  The rest of the functionality implemented for this lab was done as closley to specification as possible. Actual
  calls to the LockManager are limited to BufferPool, and locks are only added in calls to getPage(). You only
  release locks in transactionComplete() and releasePage(). 

Discuss and justify any changes you made to the API.
  
  None

Describe how long you spent on the lab, and whether there was anything
you found particularly difficult or confusing.

  I probably spent at least twenty hours on this lab. As I may have discussed in previous lab reports, I was
  unable to complete my SeqScan for lab1, or the entirety of lab2, so I was given someone else's code to 
  work on for lab3 and lab4. While this did not cause a problem for the grand majority of the lab, it made
  debugging the two system tests (AbortEvictionTest and testAllDirtyFails in TransactionTest) incredibly difficult.
  With help from the TA, I was able to successfully debug AbortEvictionTest. But for the life of me I can't figure
  out testAllDirtyFails. I believe it's due to something wrong in SeqScan or HeapFileIterator, but since I didn't
  write that code, it's extremely difficult to find the bug in time to make the deadline. 

  In conclusion, all unit tests pass, and all system tests pass except for testAllDirtyFails in TransactionTest.
